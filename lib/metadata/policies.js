var debug = require('debug')('ylt:policies');
var offendersHelpers = require('../offendersHelpers');

var policies = {
    "DOMelementsCount": {
        "tool": "phantomas",
        "label": "Antal DOM-element",
        "message": "<p>Ett stort antal DOM-element innebär mycket arbete för att webbläsaren ska rendera sidan.</p><p>Det fördröjer även JavaScript DOM-frågor, eftersom det finns flera elemnt att söka genom.</p>",
        "isOkThreshold": 1500,
        "isBadThreshold": 3000,
        "isAbnormalThreshold": 4500,
        "hasOffenders": false
    },
    "DOMelementMaxDepth": {
        "tool": "phantomas",
        "label": "Djup DOM",
        "message": "<p>En djup DOM försvårar CSS matchningen med DOM elementen.</p><p>Det fördröjer även JavaScript-modifieringar till DOM, eftersom ändringar av ett element leder till att webbläsaren räknar om dess föräldrars dimensioner.</p>",
        "isOkThreshold": 12,
        "isBadThreshold": 22,
        "isAbnormalThreshold": 30,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var domArrays = offenders.map(offendersHelpers.domPathToArray);

            return {
                count: offenders.length,
                tree: offendersHelpers.listOfDomArraysToTree(domArrays)
            };
        }
    },
    "iframesCount": {
        "tool": "phantomas",
        "label": "Antal iframes",
        "message": "<p>iFrames är komplexa HTML-elements. De är sidor, som vilken annan sida och webbläsaren behöver även skapa även denna sida inuti den befintliga sidan vilket påverkar prestandan.</p>",
        "isOkThreshold": 3,
        "isBadThreshold": 15,
        "isAbnormalThreshold": 30,
        "hasOffenders": false
    },
    "DOMidDuplicated": {
        "tool": "phantomas",
        "label": "Duplicerade IDs",
        "message": "<p>IDs eller HTML-element måste vara unika för hela dokumentet. Detta kan leda till problem med att getElementById returnerar fel element.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 5,
        "isAbnormalThreshold": 50,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    var parts = /^(.*): ?(\d+) ?occurrences$/.exec(offender);

                    if (!parts) {
                        debug('DOMidDuplicated offenders transform function error with "%s"', offender);
                        return {
                            parseError: offender
                        };
                    }

                    return {
                        id: parts[1],
                        occurrences: parseInt(parts[2], 10)
                    };
                })
            };
        }
    },
    "DOMaccesses": {
        "tool": "jsExecutionTransformer",
        "label": "DOM access",
        "message": "<p>This metric counts the number of calls to DOM related functions (both native DOM functions and jQuery functions) on page load.</p><p>The more your JavaScript code accesses the DOM, the slower the page will load.</p><p>Try, as much as possible, to have an HTML page fully generated by the server instead of making changes with JS.</p><p>Try to reduce the number of queries by refactoring your JavaScript code.</p><p>Binding too many events also has a cost. Try to use <a href=\"https://learn.jquery.com/events/event-delegation/\" target=\"_blank\">event delegation</a> as much as possible.</p>",
        "isOkThreshold": 200,
        "isBadThreshold": 2000,
        "isAbnormalThreshold": 4000,
        "hasOffenders": false
    },
    "queriesWithoutResults": {
        "tool": "jsExecutionTransformer",
        "label": "Queries without result",
        "message": "<p>Number of queries that return no result. Both native and jQuery DOM requests are counted.</p><p>It suggests the query is not used on the page, probably because it is some dead code.</p><p>Or maybe the code is trying to find an HTML block that is not always here. Look at the JS Timeline to see if the scripts correctly figures out the HTML block is not here and immediatly stops interacting further with the DOM.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 150,
        "isAbnormalThreshold": 250,
        "hasOffenders": false
    },
    "eventsScrollBound": {
        "tool": "phantomas",
        "label": "Scroll events bound",
        "message": "<p>Number of 'scroll' event listeners binded to 'window' or 'document'.</p><p>Asking too much work to the browser on scroll hurts the smoothness of the scroll. Merging all your event listeners into an unique listener can help you factorize their code and reduce their footprint on scroll.</p>",
        "isOkThreshold": 1,
        "isBadThreshold": 8,
        "isAbnormalThreshold": 15,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    var parts = /^bound by (.*) on ([^ ]+)$/.exec(offender);

                    if (!parts) {
                        debug('eventsScrollBound offenders transform function error with "%s"', offender);
                        return {
                            parseError: offender
                        };
                    }

                    var backtraceArray = offendersHelpers.backtraceToArray(parts[1]);
                    
                    return {
                        backtrace: backtraceArray || [],
                        target: parts[2]
                    };
                })
            };
        }
    },
    "jsErrors": {
        "tool": "phantomas",
        "label": "JavaScript fel",
        "message": "<p>Antal JavaScript fel på sidan.</p><p><b>Vänligen notera att vissa fel endast uppstår PhantomJS-webbläsare, så du bör dubbelkolla på andra webbläsare.</b></p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 4,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    var parts = /^(.*) - (.*)$/.exec(offender);

                    if (!parts) {
                        debug('jsErrors offenders transform function error with "%s"', offender);
                        return {
                            parseError: offender
                        };
                    }

                    var backtraceArray = offendersHelpers.backtraceToArray(parts[2]);

                    return {
                        error: parts[1],
                        backtrace: backtraceArray || []
                    };
                })
            };
        }
    },
    "documentWriteCalls": {
        "tool": "phantomas",
        "label": "document.write calls",
        "message": "<p>They slow down the page construction, especially if they are used to insert scripts in the page. Remove them ASAP.</p><p>If you cannot remove them because they come from a third-party script (such as ads), have a look at <a href=\"https://github.com/krux/postscribe\" target=\"_blank\">PostScribe</a>.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 3,
        "isAbnormalThreshold": 8,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    var parts = /^document.write(ln)?\(\) used from (.*)$/.exec(offender);

                    if (parts) {

                        var writeFn = 'document.write' + (parts[1] || '');

                        var methodParts = /^([^\s]+) \((.+):(\d+)\)$/.exec(parts[2]);
                        if (methodParts) {
                            return {
                                writeFn: writeFn,
                                from: {
                                    functionName: methodParts[1],
                                    file: methodParts[2],
                                    line: methodParts[3]
                                }
                            };
                        } else {
                            var noMethodParts = /^(.+):(\d+)$/.exec(parts[2]);

                            if (noMethodParts) {
                                return {
                                    writeFn: writeFn,
                                    from: {
                                        file: noMethodParts[1],
                                        line: noMethodParts[2]
                                    }
                                };
                            }
                        }
                    }

                    debug('documentWriteCalls offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                })
            };
        }
    },
    "synchronousXHR": {
        "tool": "phantomas",
        "label": "Synkroniserade Ajax-förfrågningar",
        "message": "<p>Making an XMLHttpRequest with the <i>async</i> option set to <i>false</i> is deprecated due to the negative effect to performances. The browser's main thread needs to stop everything until the response is received.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 1,
        "hasOffenders": true
    },
    "consoleMessages": {
        "tool": "phantomas",
        "label": "Konsolmeddelanden",
        "message": "<p>Try to keep your console clean when in production. Debugging is good for development only.</p><p>Writing in the console has a cost, especially when dumping large object variables.</p><p>There is also a problem with Internet Explorer 8, not knowing the console object.</p>",
        "isOkThreshold": 3,
        "isBadThreshold": 20,
        "isAbnormalThreshold": 50,
        "hasOffenders": false
    },
    "globalVariables": {
        "tool": "phantomas",
        "label": "Global variables",
        "message": "<p>It is a bad practice because they clutter up the global namespace. If two scripts use the same variable name in the global scope, it can cause conflicts and it is generally hard to debug.</p><p>Global variables also take a (very) little bit longer to be accessed than variables in the local scope of a function.</p>",
        "isOkThreshold": 40,
        "isBadThreshold": 200,
        "isAbnormalThreshold": 700,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offendersHelpers.sortVarsLikeChromeDevTools(offenders)
            };
        }
    },
    "jQueryVersion": {
        "label": "jQuery version",
        "message": "<p>Har du senaste versionen av jQuery?</p><p>Varje ny version av jQuery optimerar prestanden. Ligg ej kvar i en gammal version av jQuery. Uppdatera jQuery kan ibland bryta några saker, men generellt så är det ganska lätt att fixa dessa.</p>",
        "hasOffenders": false,
        "scoreFn": function(data) {
            var differentVersions = data.toolsResults.phantomas.metrics.jQueryVersionsLoaded;

            if (differentVersions === 0 || differentVersions > 1 || !data.toolsResults.phantomas.metrics.jQueryVersion) {
                // Not applicable
                return null;
            } else {
                var value = data.toolsResults.phantomas.metrics.jQueryVersion;
                var score;

                if (value.indexOf('3.3.') === 0 ||
                    value.indexOf('3.4.') === 0 ||
                    value.indexOf('3.5.') === 0 ||
                    value.indexOf('4.0.') === 0) {
                    score = 100;
                } else if (value.indexOf('3.2.') === 0) {
                    score = 90;
                } else if (value.indexOf('3.1.') === 0) {
                    score = 70;
                } else if (value.indexOf('3.0.') === 0) {
                    score = 50;
                } else if (value.indexOf('1.12.') === 0 ||
                           value.indexOf('2.2.') === 0) {
                    score = 40;
                } else if (value.indexOf('1.11.') === 0 ||
                           value.indexOf('2.1.') === 0) {
                    score = 30;
                } else if (value.indexOf('1.10.') === 0 ||
                           value.indexOf('2.0.') === 0) {
                    score = 20;
                } else if (value.indexOf('1.9') === 0) {
                    score = 10;
                } else if (value.indexOf('1.9') === 0 ||
                           value.indexOf('1.8') === 0 ||
                           value.indexOf('1.7') === 0 ||
                           value.indexOf('1.6') === 0 ||
                           value.indexOf('1.5') === 0 ||
                           value.indexOf('1.4') === 0 ||
                           value.indexOf('1.3') === 0 ||
                           value.indexOf('1.2') === 0) {
                    score = 0;
                } else {
                    debug('Unknown jQuery version "%s"', value);
                    return null;
                }

                // Truncate version number (can be long sometimes, no clue why but it can...)
                if (value.length > 30) {
                    value = value.substr(0, 28) + '...';
                }

                return {
                    value: value,
                    score: score,
                    bad: value < 100,
                    abnormal: false,
                    abnormalityScore: 0
                };
            }
        }
    },
    "jQueryVersionsLoaded": {
        "tool": "phantomas",
        "label": "Flera jQuery",
        "message": "<p>jQuery är ett tungt bibliotek. Du bör <b>aldrig</b> ladda jQuery mer än en gång på samma sida.</p>",
        "isOkThreshold": 1,
        "isBadThreshold": 2,
        "isAbnormalThreshold": 2,
        "hasOffenders": true
    },
    "cssParsingErrors": {
        "tool": "phantomas",
        "label": "CSS-syntax problem",
        "message": "<p>Vi misslyckades att analysera en CSS-fil, vilket kan tyda på problem.</p><p>Kanske kan <a href=\"http://jigsaw.w3.org/css-validator\" target=\"_blank\">CSS validator</a> kan hjälpa dig mer.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 20,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    if (offender === '[inline CSS] (Empty CSS was provided)') {
                        return {
                            error: 'Empty style tag',
                            file: null,
                            line: null,
                            column: null
                        };
                    }

                    var parts = /^(?:(?:<([^ \(]*)>|\[inline CSS\]) ?)?(?:\((((?! @ ).)*)(?: @ (\d+):(\d+))?\))?$/.exec(offender);

                    if (parts) {
                        return {
                            error: parts[2] || 'Unknown parsing error' + (parts[1] ? '. The entire file was ignored. As a result, the other CSS metrics and scores are miscalculated.' : ''),
                            file: parts[1] || null,
                            line: (parts[4] && parts[5]) ? parseInt(parts[4], 10) : null,
                            column: (parts[4] && parts[5]) ? parseInt(parts[5], 10) : null
                        };
                    }

                    // Try another syntax
                    parts = /^(.*) <(.*)> @ (\d+):(\d+)$/.exec(offender);

                    if (parts) {
                        return {
                            error: parts[1] || 'Unknown parsing error',
                            file: parts[2] || null,
                            line: parseInt(parts[3], 10),
                            column: parseInt(parts[4], 10)
                        };
                    }


                    debug('cssParsingErrors offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                })
            };
        }
    },
    "cssRules": {
        "tool": "phantomas",
        "label": "Antal regler",
        "message": "<p>Att ha för många CSS-regler påverkar din prestanda. Om antalet CSS-regler är större än antal DOM-element så finns det uppenbarligen ett problem.</p><p>Stora stylesheets är vanligt förekommande när de olika sidorna på en webbplats laddar all CSS som är sammanfogade i en stylesheet, även om en stor del av reglerna egentligen är sidspecifika. Lösningen är att skapa en huvud CSS-fil med globala regler och en anpassad fil per sida.</p>",
        "isOkThreshold": 1000,
        "isBadThreshold": 3000,
        "isAbnormalThreshold": 4500,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var hasInline = false;
            var inlineCount = 0;
            var files = [];

            offenders.forEach(function(line) {
                if (line.indexOf('[inline CSS]: ') === 0) {
                    hasInline = true;
                    inlineCount += parseInt(line.substr(14));
                } else {
                    var parts = /^<(.*)>: (\d+)$/.exec(line);

                    if (parts) {
                        files.push({
                            file: parts[1],
                            rules: parseInt(parts[2], 10)
                        });
                    }
                }
            });

            if (hasInline) {
                files.push({
                    file: 'inline CSS',
                    rules: inlineCount
                });
            }

            return {
                count: files.length,
                list: files
            };
        }
    },
    "cssComplexSelectors": {
        "tool": "phantomas",
        "label": "Komplexa-selectors",
        "message": "<p>Complex selectors are CSS selectors with 4 or more expressions, like \"#header ul li .foo\".</p><p>They are adding more work for the browser, and this could be avoided by simplifying selectors. The <a href=\"http://getbem.com\" target=\"_blank\">B.E.M. methodology</a> is an useful way to simplify your CSS.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 800,
        "isAbnormalThreshold": 2000,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);
                return splittedOffender;
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssColors": {
        "tool": "phantomas",
        "label": "Antal färger",
        "message": "<p>This is the number of different colors defined in CSS.</p><p>Your CSS will be easier to maintain if you keep a small color set.</p>",
        "isOkThreshold": 50,
        "isBadThreshold": 150,
        "isAbnormalThreshold": 400,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders, ruleObject) {
            var deduplicatedObj = {};

            offenders.map(function(offender) {
                var parts = /^([^ ]*) \((\d+) times\)$/.exec(offender);

                if (!parts) {
                    debug('cssColors offenders transform function error with "%s"', offender);
                    return;
                }

                var color = parts[1];
                var count = parseInt(parts[2], 10);

                deduplicatedObj[color] = (deduplicatedObj[color] || 0) + count;
            });

            var deduplicatedTable = [];
            for (var color in deduplicatedObj) {
                deduplicatedTable.push({
                    color: color,
                    occurrences: deduplicatedObj[color]
                });
            }

            deduplicatedTable.sort(function(a, b) {
                return b.occurrences - a.occurrences;
            });

            // Override rules.value
            ruleObject.value = deduplicatedTable.length;

            return {
                count: deduplicatedTable.length,
                palette: deduplicatedTable
            };
        }
    },
    "similarColors": {
        "tool": "colorDiff",
        "label": "Liknande färger",
        "message": "<p>This is the list of colors found in the stylesheets, that are very close to each other. The eye can barely see the difference.</p><p>Use this list to reduce the number of colors in your palette, it will be easier to maintain.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 40,
        "isAbnormalThreshold": 80,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders
            };
        }
    },
    "cssBreakpoints": {
        "tool": "mediaQueriesChecker",
        "label": "Antal Breakpoints",
        "message": "<p>This is the number of different breakpoints found in the stylesheets' media queries.</p><p>Please note this rule is based on <i>min-width</i>, <i>max-width</i>, <i>min-device-width</i> and <i>max-device-width</i> media queries only.</p><p>Your CSS will be easier to maintain if you keep a reasonable number of breakpoints. Try to make a fluid design - using percents - to avoid the creation of numerous breakpoints.</p>",
        "isOkThreshold": 6,
        "isBadThreshold": 40,
        "isAbnormalThreshold": 60,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var offendersTable = [];

            for (var offender in offenders) {
                offendersTable.push({
                    breakpoint: offender,
                    count: offenders[offender].count,
                    pixels: offenders[offender].pixels
                });
            }

            return offendersTable;
        }
    },
    "cssMobileFirst": {
        "tool": "mediaQueriesChecker",
        "label": "Ej mobile-first media queries",
        "message": "<p>This is the number of CSS rules inside media queries that address small screens.</p><p>The common good practice, when creating a responsive website, is to write it \"mobile-first\". More explanation in <a href=\"http://www.sitepoint.com/introduction-mobile-first-media-queries\" target=\"_blank\">this great article</a>.</p>",
        "isOkThreshold": 50,
        "isBadThreshold": 250,
        "isAbnormalThreshold": 1000,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return offendersHelpers.orderByFile(offenders);
        }
    },
    "cssImports": {
        "tool": "phantomas",
        "label": "Anvädning av @import",
        "message": "<p>It’s bad for performance to use @import because CSS files don't get downloaded in parallel.</p><p>You should use &lt;link rel='stylesheet' href='a.css'&gt; instead.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 1,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    var splittedOffender = offendersHelpers.cssOffenderPattern(offender);
                    return splittedOffender;
                })
            };
        }
    },
    "cssDuplicatedSelectors": {
        "tool": "phantomas",
        "label": "Duplicerade selectors",
        "message": "<p>När två eller fler selectors är identiska och bör sammanfogas.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 50,
        "isAbnormalThreshold": 100,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var parts = /^(.*) \((\d+) times\) ?<(.*)>$/.exec(offender);

                if (!parts) {
                    debug('cssDuplicatedSelectors offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                return {
                    rule: parts[1],
                    occurrences: parseInt(parts[2], 10),
                    file: parts[3]
                };
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssDuplicatedProperties": {
        "tool": "phantomas",
        "label": "Duplicerade properties",
        "message": "<p>This is the number of property definitions duplicated within a selector.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 60,
        "isAbnormalThreshold": 120,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var parts = /^([^{]+) {([^ ]+): (.+)}$/.exec(splittedOffender.css);

                if (!parts) {
                    debug('cssDuplicatedProperties offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                return {
                    property: parts[2],
                    rule: parts[1],
                    file: splittedOffender.file,
                    line: splittedOffender.line,
                    column: splittedOffender.column
                };
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssEmptyRules": {
        "tool": "phantomas",
        "label": "Tomma regler",
        "message": "<p>Enkel lösning, ta bort alla tomma regler ;)</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 50,
        "isAbnormalThreshold": 100,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(offendersHelpers.cssOffenderPattern);
            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssExpressions": {
        "tool": "phantomas",
        "label": "CSS expression",
        "message": "<p>Exempelvis: expression( document.body.clientWidth > 600 ? \"600px\" : \"auto\" )</p><p>Detta är bad practice och segar ner webbläsaren. Det finns enklare CSS3-metoder.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 20,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var parts = /^(.*) {([^ ]+): expression\((.*)\)}$/.exec(splittedOffender.css);

                if (!parts) {
                    debug('cssExpressions offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                return {
                    rule: parts[1],
                    property: parts[2],
                    expression: parts[3],
                    file: splittedOffender.file,
                    line: splittedOffender.line,
                    column: splittedOffender.column
                };
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssImportants": {
        "tool": "phantomas",
        "label": "Användning av !important",
        "message": "<p>Detta kan vara användbart, men endast som en sista utväg. Det är inte att rekommendera då det kör över den normala kaskadlogiken. Desto mer du använder !important, ju mer kommer du att behöva använda det i framtiden. Detta leder till dålig underhållsförmåga.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 75,
        "isAbnormalThreshold": 200,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var parts = /^(.*) {([^ ]+): (.*) ?\!important}$/.exec(splittedOffender.css);

                if (!parts) {
                    debug('cssImportants offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                return {
                    rule: parts[1],
                    property: parts[2],
                    value: parts[3],
                    file: splittedOffender.file,
                    line: splittedOffender.line,
                    column: splittedOffender.column
                };
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssOldIEFixes": {
        "tool": "phantomas",
        "label": "Gamla IE fix",
        "message": "<p>Vilka webbläsare behöver du stödja? När du har svaret kan du undersöka gamla regler som förorenar din CSS-kod och kan ta bort dem.</p><p>IE6:<ul><li>* html</li><li>html > body (everything but IE6)</li></ul><p><p>IE7:<ul><li><b>*</b>height: 123px;</li><li>height: 123px <b>!ie</b>;</li></ul><p><p>IE9:<ul><li>-ms-filter</li><li>progid:DXImageTransform.Microsoft</li></ul></p>",
        "isOkThreshold": 0,
        "isBadThreshold": 50,
        "isAbnormalThreshold": 150,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var parts = /^([^{]*)( {([^ ]+): (.*)})?$/.exec(splittedOffender.css);

                if (!parts) {
                    debug('cssOldIEFixes offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                var rule = parts[1];
                var property = parts[3];
                var value = parts[4];
                var browser = null;

                if (rule.indexOf('* html') === 0) {
                    rule = rule.replace(/^\* html/, '<b>* html</b>');
                    browser = 'IE6';
                } else if (rule.indexOf('html>body') === 0) {
                    rule = rule.replace(/^html>body/, '<b>html>body</b>');
                    browser = 'IE6';
                } else if (property.indexOf('*') === 0) {
                    property = '<b>' + property + '</b>';
                    browser = 'IE7';
                } else if (value.match(/\!ie$/)) {
                    value = value.replace(/\!ie$/, '<b>!ie</b>');
                    browser = 'IE7';
                } else if (property === '-ms-filter') {
                    property = '<b>-ms-filter</b>';
                    browser = 'IE9';
                } else if (value.indexOf('progid:DXImageTransform.Microsoft') >= 0) {
                    value = value.replace(/progid:DXImageTransform\.Microsoft/, '<b>progid:DXImageTransform.Microsoft</b>');
                    browser = 'IE9';
                }

                var propertyAndValue = (property && value) ? ' {' + property + ': ' + value + '}' : '';
                splittedOffender.bolded = rule + propertyAndValue;
                splittedOffender.browser = browser;

                return splittedOffender;
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssOldPropertyPrefixes": {
        "tool": "phantomas",
        "label": "Gamla prefixes",
        "message": "<p>Gamla property prefixes som -moz- eller -webkit- behövs ej något längre, eller av väldigt få personer. Du kan ta bort dom eller byta ut dom mot non-prefixed versioner. Detta kommer hjälpa dig att reducera din stylesheets storlek.</p><p>Prefix databasen är från <a href=\"http://caniuse.com/\" target=\"_blank\">Can I Use</a>.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 50,
        "isAbnormalThreshold": 200,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var properties = {};
            offenders.forEach(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var parts = /^([^{]*)(?: ?{ ?([^ ]+): (.*) ?}) \/\/ (.*)$/.exec(splittedOffender.css);

                if (!parts) {
                    debug('cssOldPropertyPrefixes offenders transform function error with "%s"', offender);
                    return {
                        parseError: offender
                    };
                }

                var propertyName = parts[2];

                if (!properties[propertyName]) {
                    properties[propertyName] = {
                        property: propertyName,
                        message: parts[4],
                        rules: []
                    };
                }

                properties[propertyName].rules.push({
                    rule: parts[1],
                    value: parts[3],
                    file: splittedOffender.file,
                    line: splittedOffender.line,
                    column: splittedOffender.column
                });
            });

            // Object to array
            var list = [];
            for (var propertyName in properties) {
                list.push(properties[propertyName]);
            }

            return {
                count: offenders.length,
                list: list
            };
        }
    },
    "cssRedundantBodySelectors": {
        "tool": "phantomas",
        "label": "Redundanta body selectors",
        "message": "<p>Detta är ett sätt att ta bort komplexitet från CSS-regler. Generellt, när \"body\" är specifierat i en regel så kan det tas bort, efter ett element behövs i body.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 60,
        "isAbnormalThreshold": 200,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);
                splittedOffender.bolded = splittedOffender.css.replace(/body/, '<b>body</b>');
                return splittedOffender;
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "cssRedundantChildNodesSelectors": {
        "tool": "phantomas",
        "label": "Redundanta tags selectors",
        "message": "<p>Some tags included inside other tags are obvious. For example, when \"ul li\" is specified in a rule, \"ul\" can be removed because the \"li\" tag is nearly always inside an \"ul\" container (the \"ol\" container is quite rare). Same thing for \"tr td\", \"select option\", ...</p><p>Lowering compexity in CSS selectors can make the page load a little faster.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 60,
        "isAbnormalThreshold": 200,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            var parsedOffenders = offenders.map(function(offender) {
                var splittedOffender = offendersHelpers.cssOffenderPattern(offender);

                var rule = splittedOffender.css || '';
                var redundanters = [
                    ['ul', 'li'],
                    ['ol', 'li'],
                    ['select', 'option'],
                    ['table', 'tr'],
                    ['table', 'th'],
                ];

                redundanters.forEach(function(couple) {
                    rule = rule.replace(new RegExp('(^| |>)' + couple[0] + '([^ >]*)?([ >]| > )' + couple[1] + '([^\\w-]|$)', 'g'), '$1<b>' + couple[0] + '</b>$2$3<b>' + couple[1] + '</b>$4');
                });

                splittedOffender.bolded = rule;

                return splittedOffender;
            });

            return offendersHelpers.orderByFile(parsedOffenders);
        }
    },
    "totalWeight": {
        "tool": "redownload",
        "label": "Total sidstorlek",
        "message": "<p>Sidstorlek är självklart viktigt om du vill ha en snabb sida. Försök, om möjligt, ligga under 1MB</p><p>Vänligen notera att motorn (PhantomJS) ej är kompatibel med image srcset (förutom om du inte använder polyfill). Detta kan leda till en inkorrekt sidstorlek.</p>",
        "isOkThreshold": 1048576,
        "isBadThreshold": 2621440,
        "isAbnormalThreshold": 4194304,
        "hasOffenders": true,
        "unit": 'bytes'
    },
    "imageOptimization": {
        "tool": "redownload",
        "label": "Bildkomprimering",
        "message": "<p>Vi mäter hur många myes som kan sparas genom att komprimera bilder.</p><p>Bildoptimering är i allmänhet ett av de enklaste sätten att minska sidstorleken och således även hastigheten att ladda sidan. Använd helst inte Photoshop eller andra bildredigeringsverktyg, de är oftast inte bra för optimerinng. Använd gärna specialiserade verktyg som, <a href=\"https://kraken.io/\" target=\"_blank\">Kraken.io</a>  eller <a href=\"https://imageoptim.com/\" target=\"_blank\">ImageOptim</a> för Mac. För SVG bilder, kan ni använda <a href=\"https://jakearchibald.github.io/svgomg/\" target=\"_blank\">SVGOMG</a></p>.<p>Vänligen notera att motorn (PhantomJS) ej är kompatibel med image srcset (förutom om du inte använder polyfill). Detta kan leda till en inkorrekt sidstorlek.</p>",
        "isOkThreshold": 20480,
        "isBadThreshold": 204800,
        "isAbnormalThreshold": 307200,
        "hasOffenders": true,
        "unit": 'bytes'
    },
    "gzipCompression": {
        "tool": "redownload",
        "label": "Gzip-komprimering",
        "message": "<p>Mäter antal bytes som kan sparas genom att komprimera filöverförningar.</p><p>Notera att gzipa mindre filer (< 1kb) är argumenterbart och att vissa filer, som exempelvis bilder inte ska gzipas eftersom de redan ä komprimerade.  <a href=\"https://gist.github.com/gmetais/971ce13a1fbeebd88445\" target=\"_blank\">Här</a> är en lista på saker som kan gzipas.</p>",
        "isOkThreshold": 5125,
        "isBadThreshold": 81920,
        "isAbnormalThreshold": 153600,
        "hasOffenders": true,
        "unit": 'bytes'
    },
    "fileMinification": {
        "tool": "redownload",
        "label": "Filminifiering",
        "message": "<p>Det här är storleken som kunde ha sparats om alla resurser var korrekt minifierade.</p><p>Verktygen som används är <b>UglifyJS</b>, <b>clean-css</b> och <b>HTMLMinifier</b>.</p>",
        "isOkThreshold": 5125,
        "isBadThreshold": 61440,
        "isAbnormalThreshold": 122880,
        "hasOffenders": true,
        "unit": 'bytes'
    },
    "totalRequests": {
        "tool": "redownload",
        "label": "Antal serverförfrågningar",
        "message": "<p>Detta kan vara en av de vanligaste orsakerna till en seg sida. Varje förfrågan påverkar sidladdningen.</p><p>Det finns flera tekniker för att reducera antalet förfrågningar:<ul><li>Sammanfoga JS-filer</li><li>Sammanfoga CSS-filer</li><li>Bädda in eller inlina små JS/CSS filer direkt i HTML.</li><li>Skapa sprites</li><li>Inlinea bilder direkt i HTML genom base64.</li><li>Använd lazyloading för bilder.</li></ul></p>",
        "isOkThreshold": 20,
        "isBadThreshold": 120,
        "isAbnormalThreshold": 200,
        "hasOffenders": true
    },
    "domains": {
        "tool": "phantomas",
        "label": "Olika domäner",
        "message": "<p>Webbläsare måste göra en DNS-uppslagning för varje domän. Undvik att ha många förfrågningar från olika domäner så att sidan kan renderas snabbare.</p>",
        "isOkThreshold": 10,
        "isBadThreshold": 25,
        "isAbnormalThreshold": 50,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders.map(function(offender) {
                    var parts = /^([^ ]*): (\d+) request\(s\)$/.exec(offender);

                    if (!parts) {
                        debug('domains offenders transform function error with "%s"', offender);
                        return {
                            file: offender
                        };
                    }

                    return {
                        domain: parts[1],
                        requests: parseInt(parts[2])
                    };
                })
            };
        }
    },
    "notFound": {
        "tool": "phantomas",
        "label": "404, sidan kunde ej hittas",
        "message": "<p>404 felmeddelanden cachas aldrig, så varje gång en sida frågar efter det så kommer det gå en förfrågan till servern. Även om man ligger bakom en CDN eller en reverse-proxy cache.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 1,
        "hasOffenders": true
    },
    "closedConnections": {
        "tool": "phantomas",
        "label": "Stängda anslutningar",
        "message": "<p>This counts the number of requests not keeping the connection alive (specifying \"Connection: close\" in the response headers). It is only counting a request if it is followed by another request on the same domain.</p><p>This is slowing down the next request, because the brower needs to open a new connection to the server, which means an additional round-trip.</p><p>Correct the problem by setting a Keep-Alive header on the guilty server.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 4,
        "isAbnormalThreshold": 15,
        "hasOffenders": true
    },
    "identicalFiles": {
        "tool": "redownload",
        "label": "Identiskt innehåll",
        "message": "<p>Antal förfrågningar som kunde ha undvikts. Undvik att ha filer som har samma inneåll men som laddas från olika URLer.</p><p>Försök ladda dom från en och samma URL.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 5,
        "isAbnormalThreshold": 15,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "emptyRequests": {
        "tool": "redownload",
        "label": "Tomma förfrågningar",
        "message": "<p>Lista med GET-förfrågningar som svarar med en tom body. Dessa är nog de enklaste förfrågningar att ta bort.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 1,
        "isAbnormalThreshold": 5,
        "hasOffenders": true
    },
    "smallRequests": {
        "tool": "redownload",
        "label": "Små förfrågningar",
        "message": "<p>Lista med alla förfrågningar som är mindre än 2 KB. Försök sammanfoga dessa med andra filer.</p>",
        "isOkThreshold": 10,
        "isBadThreshold": 50,
        "isAbnormalThreshold": 80,
        "hasOffenders": true
    },
    "hiddenImages": {
        "tool": "phantomas",
        "label": "Gömda bilder",
        "message": "<p>Lista med bilder som har display:none (eller en av deras föräldrar). Dessa laddas av webbläsaren även om de inte är synliga.</p><p>Eftersom bilder som visas i 1x1 pixlar  tenderar att vara trackers, är de uteslutna från denna regel.</p>",
        "isOkThreshold": 1,
        "isBadThreshold": 12,
        "isAbnormalThreshold": 30,
        "hasOffenders": true
    },
    "fontsCount": {
        "tool": "redownload",
        "label": "Antal webbfonter",
        "message": "<p>Antal webbfonter som laddas på sidan.</p><p>Webbfonter är bra men tyngre scripts än många tror. Du bör försöka ladda så få som möjligt.</p>",
        "isOkThreshold": 1,
        "isBadThreshold": 5,
        "isAbnormalThreshold": 7,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "heavyFonts": {
        "tool": "redownload",
        "label": "Stora webbfonter",
        "message": "<p>This metric is the sum of all bytes above 40KB in loaded fonts. Over this size, the font is probably not optimized for the web.</p><p>It can be a compresson issue, a font that contains too many glyphs or a font with complex shapes.</p><p>Sorry, Yellow Lab Tools is not yet compatible with the WOFF2 font format that generates 20-30% smaller fonts. You can proceed to a manual verification on a modern browser.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 102400,
        "isAbnormalThreshold": 204800,
        "unit": 'bytes',
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return offenders;
        }
    },
    "http2": {
        "label": "HTTP/2 eller SPDY",
        "message": "<p>HTTP/2 är det senaste versionen av HTTP-protokollet  och är utformat för att optimera hastigheten. SPDY är deprecerad men fortfarande väldigt bra.</p><p>De senaste versionerna av alla större webbläsare är nu kompatibla. Svårigheterna ligger på serverns sida, där tekniken inte är helt klar än.</p>",
        "hasOffenders": true,
        "scoreFn": function(data) {
            if (!data.toolsResults.http2) {
                return null;
            }

            var isHttp2 = data.toolsResults.http2.metrics.http2;

            var result = {
                value: isHttp2 ? 'Yes' : 'No',
                score: isHttp2 ? 100 : 0,
                bad: !isHttp2,
                abnormal: false,
                abnormalityScore: 0
            };

            if (data.toolsResults.http2.offenders) {
                result.offendersObj = {
                    count: data.toolsResults.http2.offenders.http2.length,
                    list: data.toolsResults.http2.offenders.http2
                };
            }

            return result;
        }
    },
    "cachingDisabled": {
        "tool": "phantomas",
        "label": "Cachning inaktiverad",
        "message": "<p>Antal svar där cacning är inaktiverad(max-age=0)</p><p>Fixa gärna om det är statiska resurser.</p>",
        "isOkThreshold": 0,
        "isBadThreshold": 12,
        "isAbnormalThreshold": 25,
        "hasOffenders": true
    },
    "cachingNotSpecified": {
        "tool": "phantomas",
        "label": "Cachning inte specificerad",
        "message": "<p>När ingen cache är specificerad, hanterar varje webbläsare situationen annorlunda. Mestadels lägger det automatiskt till cache men en som ej är optimerad.</p>",
        "isOkThreshold": 5,
        "isBadThreshold": 20,
        "isAbnormalThreshold": 40,
        "hasOffenders": true
    },
    "cachingTooShort": {
        "tool": "phantomas",
        "label": "Cachning för kort",
        "message": "<p>Svar med för kort cache-tid (mindre än en vecka).</p><p>Ju längre du kan cacha The longer you cachea, desto bättre. Lägg till version till dina statiska resurser, och ställ in cache-tiden till ett år om möjligt.</p>",
        "isOkThreshold": 5,
        "isBadThreshold": 20,
        "isAbnormalThreshold": 40,
        "hasOffenders": true,
        "offendersTransformFn": function(offenders) {
            return {
                count: offenders.length,
                list: offenders
                    .map(function(offender) {
                        var parts = /^([^ ]*) cached for (-?\d+(\.\d+)?) s$/.exec(offender);

                        if (!parts) {
                            debug('cachingTooShort offenders transform function error with "%s"', offender);
                            return {
                                file: offender
                            };
                        }

                        return {
                            file: parts[1],
                            ttl: Math.round(parseFloat(parts[2]))
                        };

                    }).sort(function(a, b) {

                        return a.ttl - b.ttl;

                    }).map(function(obj) {

                        var duration = obj.ttl;
                        var unit = 'seconds';

                        if (duration >= 120) {
                            duration = Math.round(duration / 60);
                            unit = 'minutes';
                        }

                        if (duration >= 120) {
                            duration = Math.round(duration / 60);
                            unit = 'hours';
                        }

                        if (duration >= 48) {
                            duration = Math.round(duration / 24);
                            unit = 'days';
                        }

                        obj.ttlWithUnit = duration;
                        obj.unit = unit;

                        return obj;
                    })
            };
        }
    }
};

module.exports = policies;
